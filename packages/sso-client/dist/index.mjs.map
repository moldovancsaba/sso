{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * Error types that can be thrown by the SSO client\n */\nexport enum SSOErrorType {\n  NETWORK = 'NETWORK_ERROR',\n  VALIDATION = 'VALIDATION_ERROR',\n  AUTHENTICATION = 'AUTHENTICATION_ERROR',\n  CONFIGURATION = 'CONFIGURATION_ERROR'\n}\n\n/**\n * Custom error class for SSO-related errors\n */\nexport class SSOError extends Error {\n  constructor(\n    message: string,\n    public readonly type: SSOErrorType,\n    public readonly cause?: unknown\n  ) {\n    super(message);\n    this.name = 'SSOError';\n  }\n}\n\n/**\n * Options for configuring the SSO client\n */\nexport interface SSOClientOptions {\n  /** Custom path for login redirection. Defaults to '/' */\n  loginPath?: string;\n  /** Custom path for logout endpoint. Defaults to '/api/users/logout' */\n  logoutPath?: string;\n  /** Custom path for session validation. Defaults to '/api/sso/validate' */\n  validatePath?: string;\n  /** Additional headers to include in requests */\n  headers?: Record<string, string>;\n  /** Timeout for requests in milliseconds. Defaults to 10000 (10 seconds) */\n  timeout?: number;\n  /** Auto-retry configuration for failed requests */\n  retry?: {\n    /** Maximum number of retry attempts. Defaults to 3 */\n    maxAttempts?: number;\n    /** Base delay between retries in milliseconds. Defaults to 1000 (1 second) */\n    baseDelay?: number;\n  };\n}\n\n/**\n * Session validation response\n */\nexport interface SessionResponse {\n  /** Whether the session is valid */\n  isValid: boolean;\n  /** Error message if session is invalid */\n  message?: string;\n  /** User information if session is valid */\n  user?: {\n    id: string;\n    username: string;\n    permissions: {\n      isAdmin: boolean;\n      canViewUsers: boolean;\n      canManageUsers: boolean;\n      [key: string]: boolean;\n    };\n  };\n  /** Session information if valid */\n  session?: {\n    expiresAt: string;\n  };\n}\n\n/**\n * DoneIsBetter SSO Client\n * \n * Provides methods for SSO authentication and session management\n */\n/**\n * Utility function to add exponential backoff delay\n * @param attempt Current attempt number\n * @param baseDelay Base delay in milliseconds\n * @returns Promise that resolves after the delay\n */\nasync function backoffDelay(attempt: number, baseDelay: number): Promise<void> {\n  const delay = baseDelay * Math.pow(2, attempt - 1);\n  await new Promise(resolve => setTimeout(resolve, delay));\n}\n\n/**\n * DoneIsBetter SSO Client\n * \n * Provides methods for SSO authentication and session management with:\n * - Automatic retry with exponential backoff\n * - Request timeout handling\n * - Detailed error reporting\n * - Session monitoring\n * - Type-safe responses\n */\nexport class SSOClient {\n  // Base configuration\n  private readonly ssoServerUrl: string;\n  private readonly validateEndpoint: string;\n  private readonly logoutEndpoint: string;\n  private readonly loginPath: string;\n  private readonly headers: Record<string, string>;\n\n  // Request configuration\n  private readonly timeout: number;\n  private readonly maxRetries: number;\n  private readonly baseRetryDelay: number;\n\n  // Session monitoring state\n  private monitoringTimer?: ReturnType<typeof setInterval>;\n  private isMonitoring: boolean = false;\n\n  /**\n   * Create a new SSO client instance\n   * \n   * @param ssoServerUrl Base URL of the SSO server\n   * @param options Configuration options\n   */\n  constructor(ssoServerUrl: string, options: SSOClientOptions = {}) {\n    // Validate SSO server URL\n    if (!ssoServerUrl) {\n      throw new SSOError('SSO server URL is required', SSOErrorType.CONFIGURATION);\n    }\n\n    // Initialize base configuration\n    this.ssoServerUrl = ssoServerUrl.replace(/\\/$/, '');\n    this.validateEndpoint = `${this.ssoServerUrl}${options.validatePath || '/api/sso/validate'}`;\n    this.logoutEndpoint = `${this.ssoServerUrl}${options.logoutPath || '/api/users/logout'}`;\n    this.loginPath = options.loginPath || '/';\n    this.headers = {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json',\n      ...options.headers,\n    };\n\n    // Initialize request configuration\n    this.timeout = options.timeout || 10000;\n    this.maxRetries = options.retry?.maxAttempts || 3;\n    this.baseRetryDelay = options.retry?.baseDelay || 1000;\n  }\n\n  /**\n   * Validate the current session\n   * \n   * @returns Session validation response\n   * @throws Error if request fails\n   */\n  /**\n   * Makes a request to the SSO server with retry and timeout handling\n   * @param url Request URL\n   * @param init Request init options\n   * @returns Response from the server\n   * @throws SSOError if the request fails after retries\n   */\n  private async makeRequest(url: string, init: RequestInit): Promise<Response> {\n    let lastError: unknown;\n\n    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {\n      try {\n        // Create abort controller for timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n        const response = await fetch(url, {\n          ...init,\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n        return response;\n      } catch (error) {\n        lastError = error;\n\n        // Don't retry if request was aborted (timeout) or we're at max attempts\n        if (error instanceof Error && error.name === 'AbortError') {\n          throw new SSOError('Request timed out', SSOErrorType.NETWORK, error);\n        }\n\n        if (attempt === this.maxRetries) {\n          throw new SSOError(\n            'Request failed after max retries',\n            SSOErrorType.NETWORK,\n            lastError\n          );\n        }\n\n        // Add exponential backoff delay before retry\n        await backoffDelay(attempt, this.baseRetryDelay);\n      }\n    }\n\n    // This should never happen due to the loop above\n    throw new SSOError('Unexpected error', SSOErrorType.NETWORK, lastError);\n  }\n\n  /**\n   * Validate the current session\n   * \n   * @returns Session validation response\n   * @throws SSOError if validation fails\n   */\n  async validateSession(): Promise<SessionResponse> {\n    try {\n      const response = await this.makeRequest(this.validateEndpoint, {\n        method: 'GET',\n        credentials: 'include',\n        headers: this.headers,\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new SSOError(\n          data.message || 'Session validation failed',\n          SSOErrorType.VALIDATION,\n          data\n        );\n      }\n\n      return data;\n    } catch (error) {\n      // If it's already an SSOError, rethrow it\n      if (error instanceof SSOError) {\n        throw error;\n      }\n\n      // Otherwise wrap it in an SSOError\n      throw new SSOError(\n        'Failed to validate SSO session',\n        SSOErrorType.VALIDATION,\n        error\n      );\n    }\n  }\n\n  /**\n   * Sign out the current user\n   * \n   * @returns True if logout was successful\n   * @throws Error if request fails\n   */\n  /**\n   * Sign out the current user\n   * \n   * @returns True if logout was successful\n   * @throws SSOError if logout fails\n   */\n  async signOut(): Promise<boolean> {\n    try {\n      const response = await this.makeRequest(this.logoutEndpoint, {\n        method: 'POST',\n        credentials: 'include',\n        headers: this.headers,\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new SSOError(\n          data.message || 'Logout failed',\n          SSOErrorType.AUTHENTICATION,\n          data\n        );\n      }\n\n      // Stop session monitoring if active\n      this.stopSessionMonitoring();\n\n      return true;\n    } catch (error) {\n      if (error instanceof SSOError) {\n        throw error;\n      }\n\n      throw new SSOError(\n        'Failed to sign out',\n        SSOErrorType.AUTHENTICATION,\n        error\n      );\n    }\n  }\n\n  /**\n   * Redirect to the login page\n   * \n   * @param redirectUrl Optional URL to redirect to after login\n   */\n  /**\n   * Redirect to the login page\n   * \n   * @param redirectUrl Optional URL to redirect to after login\n   * @throws SSOError if redirect URL is invalid\n   */\n  redirectToLogin(redirectUrl?: string): void {\n    try {\n      const currentUrl = redirectUrl || window.location.href;\n      // Validate URL to prevent redirect attacks\n      new URL(currentUrl);\n      \n      const encodedUrl = encodeURIComponent(currentUrl);\n      window.location.href = `${this.ssoServerUrl}${this.loginPath}?redirect=${encodedUrl}`;\n    } catch (error) {\n      throw new SSOError(\n        'Invalid redirect URL',\n        SSOErrorType.CONFIGURATION,\n        error\n      );\n    }\n  }\n\n  /**\n   * Enable automatic session monitoring\n   * \n   * @param options Monitoring configuration\n   * @returns Cleanup function to stop monitoring\n   */\n  /**\n   * Enable automatic session monitoring\n   * \n   * @param options Monitoring configuration\n   * @returns Cleanup function to stop monitoring\n   * @throws SSOError if monitoring is already enabled\n   */\n  enableSessionMonitoring(options: {\n    /** Interval in milliseconds to check session status. Defaults to 60000 (1 minute) */\n    interval?: number;\n    /** Callback when session becomes invalid */\n    onInvalidSession?: () => void;\n    /** Callback for session check errors */\n    onError?: (error: SSOError) => void;\n  } = {}): () => void {\n    if (this.isMonitoring) {\n      throw new SSOError(\n        'Session monitoring is already enabled',\n        SSOErrorType.CONFIGURATION\n      );\n    }\n\n    const interval = Math.max(options.interval || 60000, 10000); // Minimum 10s interval\n    \n    const checkSession = async () => {\n      try {\n        const result = await this.validateSession();\n        if (!result.isValid && options.onInvalidSession) {\n          options.onInvalidSession();\n        }\n      } catch (error) {\n        if (options.onError) {\n          options.onError(\n            error instanceof SSOError\n              ? error\n              : new SSOError('Session check failed', SSOErrorType.VALIDATION, error)\n          );\n        }\n      }\n    };\n\n    // Initial check\n    void checkSession();\n\n    this.monitoringTimer = setInterval(checkSession, interval);\n    this.isMonitoring = true;\n\n    return () => this.stopSessionMonitoring();\n  }\n\n  /**\n   * Stop session monitoring if it's active\n   */\n  private stopSessionMonitoring(): void {\n    if (this.monitoringTimer) {\n      clearInterval(this.monitoringTimer);\n      this.monitoringTimer = undefined;\n      this.isMonitoring = false;\n    }\n  }\n}\n"],"mappings":"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","names":["SSOErrorType"]}