import { jest } from '@jest/globals';\n\ndescribe('SSO Client', () => {\n  let mockFetch;\n\n  beforeEach(() => {\n    mockFetch = jest.fn();\n    global.fetch = mockFetch;\n    global.window = {\n      location: {\n        href: 'http://example.com',\n      },\n    };\n  });\n\n  it('validates session successfully', async () => {\n    const validResponse = {\n      isValid: true,\n      user: { id: '123', username: 'test@example.com' },\n    };\n\n    mockFetch.mockResolvedValueOnce({\n      json: () => Promise.resolve(validResponse),\n    });\n\n    const sso = new SSOClient('http://sso.example.com');\n    const result = await sso.validateSession();\n\n    expect(result).toEqual(validResponse);\n    expect(mockFetch).toHaveBeenCalledWith(\n      'http://sso.example.com/api/sso/validate',\n      expect.objectContaining({\n        method: 'GET',\n        credentials: 'include',\n      })\n    );\n  });\n\n  it('handles session validation errors', async () => {\n    mockFetch.mockRejectedValueOnce(new Error('Network error'));\n\n    const sso = new SSOClient('http://sso.example.com');\n    const result = await sso.validateSession();\n\n    expect(result).toEqual({\n      isValid: false,\n      message: 'Failed to validate SSO session',\n    });\n  });\n\n  it('redirects to login with current URL', () => {\n    const sso = new SSOClient('http://sso.example.com');\n    sso.redirectToLogin();\n\n    expect(global.window.location.href).toBe(\n      'http://sso.example.com/?redirect=http%3A%2F%2Fexample.com'\n    );\n  });\n});\n
