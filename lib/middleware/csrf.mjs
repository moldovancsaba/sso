/**
 * lib/middleware/csrf.mjs â€” CSRF protection for state-changing operations
 * WHAT: Double-submit cookie pattern for CSRF protection without server-side session storage.
 * WHY: Prevent cross-site request forgery attacks on authentication and admin endpoints.
 * 
 * NOTE: We use double-submit cookie pattern instead of session-based synchronizer tokens
 * because our sessions are stateless cookies. This is secure when combined with SameSite cookies.
 */
import { randomBytes, createHmac } from 'crypto'
import { logSecurityEvent } from '../logger.mjs'

const CSRF_COOKIE_NAME = 'csrf-token'
const CSRF_HEADER_NAME = 'x-csrf-token'
const CSRF_TOKEN_LENGTH = 32 // 32 bytes = 64 hex characters

/**
 * getCsrfSecret
 * WHAT: Gets CSRF signing secret from environment.
 * WHY: Sign CSRF tokens to prevent attacker-generated tokens.
 */
function getCsrfSecret() {
  const secret = process.env.CSRF_SECRET || process.env.SESSION_SECRET
  if (!secret) {
    throw new Error('CSRF_SECRET or SESSION_SECRET must be set for CSRF protection')
  }
  return secret
}

/**
 * generateCsrfToken
 * WHAT: Generates cryptographically random CSRF token.
 * WHY: High entropy token resistant to guessing attacks.
 */
export function generateCsrfToken() {
  return randomBytes(CSRF_TOKEN_LENGTH).toString('hex')
}

/**
 * signCsrfToken
 * WHAT: Creates HMAC signature for CSRF token.
 * WHY: Ensures token was generated by our server, not attacker.
 */
function signCsrfToken(token) {
  const secret = getCsrfSecret()
  const hmac = createHmac('sha256', secret)
  hmac.update(token)
  return hmac.digest('hex')
}

/**
 * verifyCsrfToken
 * WHAT: Verifies CSRF token signature.
 * WHY: Reject attacker-generated tokens.
 */
function verifyCsrfToken(token, signature) {
  const expectedSignature = signCsrfToken(token)
  // Constant-time comparison to prevent timing attacks
  return timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature))
}

/**
 * timingSafeEqual
 * WHAT: Constant-time string comparison.
 * WHY: Prevent timing attacks that could leak signature validity.
 */
function timingSafeEqual(a, b) {
  if (a.length !== b.length) return false
  let result = 0
  for (let i = 0; i < a.length; i++) {
    result |= a[i] ^ b[i]
  }
  return result === 0
}

/**
 * getCsrfCookie
 * WHAT: Extracts CSRF token from cookie.
 * WHY: Double-submit pattern requires token in cookie and header.
 */
function getCsrfCookie(req) {
  const cookies = req.headers?.cookie || ''
  const parts = cookies.split(';').map(s => s.trim())
  
  for (const part of parts) {
    const eq = part.indexOf('=')
    if (eq > 0) {
      const name = part.slice(0, eq)
      const value = part.slice(eq + 1)
      if (name === CSRF_COOKIE_NAME) {
        return decodeURIComponent(value)
      }
    }
  }
  return null
}

/**
 * setCsrfCookie
 * WHAT: Sets CSRF token cookie on response.
 * WHY: Client must include this value in subsequent requests.
 */
export function setCsrfCookie(res, token) {
  const signature = signCsrfToken(token)
  const cookieValue = `${token}.${signature}`
  
  const attrs = [
    `${CSRF_COOKIE_NAME}=${encodeURIComponent(cookieValue)}`,
    'Path=/',
    'HttpOnly', // Prevent JavaScript access
    'SameSite=Lax', // CSRF protection relies on SameSite
    `Max-Age=${60 * 60 * 24}`, // 24 hours
  ]
  
  if (process.env.NODE_ENV === 'production') {
    attrs.push('Secure')
  }
  
  res.setHeader('Set-Cookie', attrs.join('; '))
}

/**
 * validateCsrf
 * WHAT: Middleware to validate CSRF token on state-changing requests.
 * WHY: Prevent CSRF attacks by requiring valid token from our domain.
 * 
 * Double-submit cookie pattern:
 * 1. Server sets CSRF token in cookie (signed)
 * 2. Client reads cookie value and includes in X-CSRF-Token header
 * 3. Server validates: header matches cookie AND signature is valid
 */
export function validateCsrf(req, res, next) {
  // Skip CSRF validation for safe methods (GET, HEAD, OPTIONS)
  const safeMethods = ['GET', 'HEAD', 'OPTIONS']
  if (safeMethods.includes(req.method)) {
    return next()
  }
  
  // Skip in development with dev bypass (testing convenience)
  if (process.env.NODE_ENV !== 'production' && process.env.ADMIN_DEV_BYPASS === 'true') {
    return next()
  }
  
  // Extract CSRF token from cookie
  const cookieValue = getCsrfCookie(req)
  if (!cookieValue || !cookieValue.includes('.')) {
    logSecurityEvent('csrf_missing_cookie', { path: req.path, method: req.method })
    return res.status(403).json({
      error: 'CSRF protection',
      message: 'CSRF token cookie missing or invalid',
    })
  }
  
  const [cookieToken, cookieSignature] = cookieValue.split('.')
  
  // Verify cookie signature
  if (!verifyCsrfToken(cookieToken, cookieSignature)) {
    logSecurityEvent('csrf_invalid_signature', { path: req.path, method: req.method })
    return res.status(403).json({
      error: 'CSRF protection',
      message: 'CSRF token signature invalid',
    })
  }
  
  // Extract CSRF token from header
  const headerToken = req.headers[CSRF_HEADER_NAME]
  if (!headerToken) {
    logSecurityEvent('csrf_missing_header', { path: req.path, method: req.method })
    return res.status(403).json({
      error: 'CSRF protection',
      message: 'CSRF token header missing',
    })
  }
  
  // Compare cookie token with header token (constant-time)
  if (!timingSafeEqual(Buffer.from(cookieToken), Buffer.from(headerToken))) {
    logSecurityEvent('csrf_token_mismatch', { path: req.path, method: req.method })
    return res.status(403).json({
      error: 'CSRF protection',
      message: 'CSRF token mismatch',
    })
  }
  
  // CSRF validation passed
  next()
}

/**
 * ensureCsrfToken
 * WHAT: Middleware to ensure CSRF cookie is set on response.
 * WHY: Clients need CSRF token before making state-changing requests.
 * 
 * Use this on login endpoints and pages that render forms.
 */
export function ensureCsrfToken(req, res, next) {
  const existingCookie = getCsrfCookie(req)
  
  // If valid CSRF cookie exists, reuse it
  if (existingCookie && existingCookie.includes('.')) {
    const [token, signature] = existingCookie.split('.')
    if (verifyCsrfToken(token, signature)) {
      // Token is valid, attach to request for convenience
      req.csrfToken = token
      return next()
    }
  }
  
  // Generate new CSRF token
  const token = generateCsrfToken()
  setCsrfCookie(res, token)
  req.csrfToken = token
  
  next()
}

/**
 * getCsrfToken
 * WHAT: Helper to get current CSRF token from request.
 * WHY: Convenience function for endpoints that need to return token to client.
 */
export function getCsrfToken(req) {
  if (req.csrfToken) return req.csrfToken
  
  const cookieValue = getCsrfCookie(req)
  if (cookieValue && cookieValue.includes('.')) {
    const [token, signature] = cookieValue.split('.')
    if (verifyCsrfToken(token, signature)) {
      return token
    }
  }
  
  return null
}
